#!/usr/bin/bash
shopt -s extglob
#source connectDB
#dbname=$(connectDB)
source common_functions
cd $HOME/DBMS_Project/Databases/omar
pwd

<< COMMENT
val_types :  1122
columns :  ID
Name
Age
City
values :  4
5
poo
ss
COMMENT
##################################################################
<< COMMENT
	Function to check the value of the primary key that the user enters if it's found in the table or not
COMMENT

function check_value(){
	ids=`cut -d: -f1 test_data | tail -n+2`
	for id in $ids
	do
		if (( id != $key ))
		then
			continue
		else
			echo "Found"
			break
		fi
	done
	
}


##################################################################
<< COMMENT
	Function to check if the value that is entered by the user is int or not "Error"
COMMENT

function check_int(){

	for i in $@
	do
		case $i in
			+([0-9]))
				return 1
				;;
			*)	
				return 2
		esac
	done

}

##################################################################
<< COMMENT
	Function to get the primary key column name
COMMENT

function get_pk(){

	pk=$(head -n1 $1 | cut -d: -f1)
	declare -a pk_col_arr=()
	declare -a pk_val_arr=()
	#echo $pk
	## convert columns into an array 
	for col in $2
	do
		pk_col_arr+=("$col")
	done
	## Convert values into an array
	for col in $3
	do
		pk_val_arr+=("$col")
	done
	len=${#pk_col_arr[@]}  # Get the length of the array

	for ((i = 0; i < len - 1; i++))
	do
		#echo "col : " "${pk_col_arr[i]}"
		#echo "val : " "${pk_val_arr[i]}"
		if [[ "${pk_col_arr[i]}" == $pk ]]
		then
			#echo "${pk_col_arr[i]}"
			#echo $i
			awk -v value="${pk_val_arr[i]}" '
			BEGIN{
				FS=":"
			}
			{
				if (value == $1){
					print "Error. This primary key is already exists!!"
					exit 1
				}
			}

			' $1
			local awk_return=$?  # Capture the exit status of the awk command
		        if [[ $awk_return == 1 ]]
			then
        		    return $awk_return  # Return the exit status if non-zero
        		fi
		fi
	done
}

##################################################################
<< COMMENT
	Function that update the table to the new value
COMMENT

function substitute(){
	awk -v columns="$1" -v values="$2" '
        BEGIN {
            FS=":"
	    # Convert 'columns' string into an array
	    num_columns = split(columns, columns_array, " ")

	    # Convert 'values' string into an array
	    num_values = split(values, values_array, " ")

	    }
        
        {
######################### get the index of each column of the users query #######################
	if (NR == 1){
	        split($0, header, ":")
		for (i = 1; i <= num_columns; i++) {
	        for (j = 1; j <= NF; j++) {
        		if (columns_array[i] == header[j]) {
				output[i] = j
			break
	       }
	       }
	       }
	}
#################################################################################################
	len = length(output)
	#print len
	if ($output[len] == values_array[num_values]){
		for (i = 1; i <= num_columns - 1 ; i++){
			$output[i] = values_array[i]
		}
	}
	gsub(" " , ":")
	print $0
            
        }
    ' "$3"
}


##################################################################

<< COMMENT
	A code to get the data types of all columns of the table from meta file
COMMENT

col_dtype=$(awk '
	    BEGIN{
		FS="="
	    }
	    {
		if ($2 =="int"){
		    col_dtype[NR] = 1
		    col_index[NR] = NR
		}
		else{
		    col_dtype[NR] = 2
	col_index[NR] = NR
		}
	    }
	    END{
	    }
' "$2"_meta)


##################################################################
<< COMMENT
	Function to compare the column types with the types of values entered by the user
COMMENT

function types_of_meta()
{
    if [[ -f $1 ]]
    then
        awk -v val_types="$2" -v columns="$3" '
        BEGIN{
            FS="="
            n_val = split(val_types, val_arr, "")
            n_col = split(columns, col_arr, " ")
        }
        {
            for(i=1;i<=n_col;i++){
                if (col_arr[i] == $1){
                    if (val_arr[i] == 1 && $2 == "int") {
                        #print "Column " $1 " is of type int"
                    } else if (val_arr[i] == 2 && $2 == "str") {
                        #print "Column " $1 " is of type string"
                    } else {
                        print "Error. Column " $1 " doesnt match expected type!!"
			exit 1
                    }
                }
            }
        }
        END{
            
        }
        ' "$1"
    else
        echo "Meta data file not found!!"
        return 1
    fi
}
##################################################################	
update_pattern="^update [a-zA-Z_]+ set [a-zA-Z_]+ = .+ where [a-zA-Z_]+ = .+$"
user_input="$*"                 # The query entered by the user all in one line

	# Check the user update query syntax
if [[ $user_input =~ $update_pattern ]]; then
    echo "Valid update statement: $user_input"
else
    echo "Syntax error!!"
    exit	
fi

# Check if the table entered by user is not found
check_table $2
temp=$? 		# temporary variable to check the return of the function

if [[ $temp != 1 ]]
then
	echo "Error : table not found"
	exit
fi

columns=$(grep -oP '\b\w+\b(?=\s*=)' <<< "$user_input")		# Extract the columns that is in the query

# Check if any of the columns is not found
for column in $columns
do
	check_column $column $2
	temp=$?   	# temporary variable to check the return of the function
	if [[ $temp != 1 ]]
	then
		echo "Error!! Column "$column" not found"
		exit
	fi
done

values=$(echo "$user_input" | grep -oP '(?<=\=\s)[\w\d]+' )		# Extract the values that is in the query
#echo "$values"
declare -a val_types=()
for val in $values
do
	check_int $val	   # The return datatype of the new values 1 for int and 2 for str
	val_types+=$?
done

index=$(head -n1 "${2}_data" | awk -F':' '{for(i=1;i<=NF;i++) print i " : " $i}')
#echo $index

i=2
declare -a out=()
for idx in $index
do
	#echo "index : " $idx
	for col in $columns
	do
		#echo "column : " $col
		if [[ $col == $idx ]]
		then
			#echo $((i/2))
			out+=($((i/2)))
		fi
	done
	((i++))
done
	
#echo "${index[*]}"
#echo "${columns[*]}"
#echo "${out[*]}"

types_of_meta "$2"_meta "${val_types[*]}" "${columns[*]}" #Check if the data types of entered values matches the data types in the meta file 

res_meta=$?			# A flag to check the return of the types of meta function
if [[ $res_meta == 1 ]]
then
	exit		# There is a data type mismatch
fi

get_pk "$2"_data "${columns[*]}" "${values[*]}" 
res_pk=$?			# A flag to check the return of the pk search function
if [[ $res_pk == 1 ]]
then
	exit		# The updated value is already a primark key in the table
fi


substitute "${columns[*]}" "${values[*]}" "$2"_data

	
###########################################################################







