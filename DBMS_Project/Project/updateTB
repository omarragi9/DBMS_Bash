#!/usr/bin/bash
shopt -s extglob
#source connectDB
#dbname=$(connectDB)
cd $HOME/DBMS_Project/Databases/omar
pwd
##################################################################
<< COMMENT
	Function to check the value of the primary key that the user enters if it's found in the table or not
COMMENT

function check_value(){
	ids=`cut -d: -f1 test_data | tail -n+2`
	for id in $ids
	do
		if (( id != $key ))
		then
			continue
		else
			echo "Found"
			break
		fi
	done
	
}

##################################################################
<< COMMENT
	Function to check if the name of the column entered by the user is in the table or not
COMMENT

function check_column(){
	if head -n1 "$2"_data | grep -q $1
		then
			return 1
		else
			return 2
	fi

}
##################################################################
<< COMMENT
	Function to check if the value that is entered by the user is int or not "Error"
COMMENT

function check_int(){

	for i in $@
	do
		case $i in
			+([0-9]))
				return 1
				;;
			*)	
				return 2
		esac
	done

}

##################################################################
<< COMMENT
	Function that update the table to the new value
COMMENT

function substitute(){
	awk -v key="$1" -v cols="$2" -v new_vals="$3" '
        BEGIN {
            FS=":"
        }

        {
            if ($1 == key) {
                split(cols, indices, " ")
                split(new_vals, values, " ")
                for (i = 1; i <= length(indices); i++) {
                    if (i in indices) {
                        $(indices[i]) = values[i]
                    }
                }
            }
            
            gsub(" ", ":")
            print $0
        }
    ' "$4"
}

##################################################################

<< COMMENT
	Function to check if this table is exist
COMMENT

function check_table(){

	if [[ -f "$1"_data ]]
	then 
		return 1
	else
		return 2
	fi


}
##################################################################

<< COMMENT
	Function to get the tpyes of columns that the user choose from meta file
COMMENT

function types_of_meta()
{
    if [[ -f $1 ]]
    then
        awk -v val_tp="$2" -v col_num_arr="$3" '
        BEGIN{
            FS="="
            n_val = split(val_tp, val_arr, "")
            n_col = split(col_num_arr, col_arr, " ")
		counter=1
        }
        {
            for (i = 1; i <= n_col; i++) {
                if (NR == col_arr[i]) {
                    dtypes[counter] = $2
		    counter++
                }
            }
        }
        END{
            for (i = 1; i <= n_val; i++) {
		#print val_arr[i] 
		#print dtypes[i]
                if ((val_arr[i] == 1 && dtypes[i] == "int") || (val_arr[i] == 2 && dtypes[i] == "str")) {
                    #print "GOOD"
                } else {
                    print "Error. Data type Mismatch!! in column " $dtypes[i]
                }
            }
        }
        ' "$1"
    else
        echo "Meta data file not found!!"
        return 1
    fi
}
##################################################################
function updateTB(){
	
	read -p "Enter your table name : " table
	check_table $table
	columns=`cat test_meta`
	echo "These are the coulmns that in your table : "
	counter=0

	for column in $columns
	do
		((counter++))
 		echo "$counter) $column"
	done
	
	read -p "Enter the index of columns you want to update \"Separated by space\": " col_num
	check_int $col_num
	temp=$?
	if (( temp == 2 ))
	then
		echo "you can't enter a string"
	fi
	read -p "Enter the primary key that of the record you want to update : " key
	check_int $key
	temp=$?
	if (( temp == 2 ))
	then
		echo "you can't enter a string"
	fi
	check_value $key

	declare -a old_val=() new_val=() val_tp=()
	counter=1
	read -r -a col_num_arr <<< "$col_num" # Converting the string col_num into an array
	for i in ${!col_num_arr[@]}
	do
		read -p "Enter the new value of the row number $counter : " new_val[$i]
		check_int "${new_val[$i]}"	   # The return datatype of the new values 1 for int and 2 for str
		val_tp+=$?
		#echo "${new_val[$i]}"
		#echo "${val_tp[$i]}"
		((counter++))
	done
	types_of_meta test_meta "${val_tp[*]}" "${col_num_arr[*]}"
	substitute "$key" "${col_num[*]}" "${new_val[*]}" "$table"
	
}
###########################################################################
update_pattern="^update [a-zA-Z_]+ set [a-zA-Z_]+ = .+ where [a-zA-Z_]+ = .+$"
user_input="$*"

# Check the user update query syntax
if [[ $user_input =~ $update_pattern ]]; then
    echo "Valid update statement: $user_input"
else
    echo "Syntax error!!"
fi

# Check if the table entered by user is not found
check_table $2
temp=$? 		# temporary variable to check the return of the function

if [[ $temp != 1 ]]
then
	echo "Error : table not found"
fi


columns=$(grep -oP '\b\w+\b(?=\s*=)' <<< "$user_input")		# Extract the columns that is in the query

# Check if any of the columns is not found
for column in $columns
do
	check_column $column $2
	temp=$?   	# temporary variable to check the return of the function
	if [[ $temp != 1 ]]
	then
		echo "Error!! Column "$column" not found"
	fi
done


values=$(echo "$user_input" | grep -oP '(?<=\=\s)[\w\d]+' )		# Extract the values that is in the query
#echo "$values"
declare -a val_types=()
for val in $values
do
	check_int $val	   # The return datatype of the new values 1 for int and 2 for str
	val_types+=$?
done


index=$(head -n1 "${2}_data" | awk -F':' '{for(i=1;i<=NF;i++) print i " " $i}')
#echo $index

i=2
declare -a out=()
for idx in $index
do
	#echo "index : " $idx
	for col in $columns
	do
		#echo "column : " $col
		if [[ $col == $idx ]]
		then
			#echo $((i/2))
			out+=($((i/2)))
		fi
	done
	((i++))
done

types_of_meta "$2"_meta "${val_types[*]}" "${out[*]}" #Check if the data types of entered values matches the data types in the meta file



updateTB 


